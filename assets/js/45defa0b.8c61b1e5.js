(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{142:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/additional-facet-production-1-fc96c4cd8147107cce114ebe9a9841ab.png"},143:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/additional-facet-production-2-60e36a87f8e6458b2ccc75d2f52ecc0d.png"},76:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var o=n(3),r=n(7),a=(n(0),n(96)),i={id:"tutorial-06",title:"Additional Facet Production"},s={unversionedId:"tutorial-06",id:"tutorial-06",isDocsHomePage:!1,title:"Additional Facet Production",description:"Another neat way to use facets is to use the data from one or more other facets to create a unique dataset.  In this example we will attempt to create random stone houses on the surface of the world.  For this,  we will create a sparse object 3d facet that will contain the bottom-center locations of each of the houses.  From there we can then create a rasterizer that loops through each of the values and creates a house wherever the facet value should contain a house.",source:"@site/docs/06_Additional-Facet-Production.md",slug:"/tutorial-06",permalink:"/TutorialWorldGeneration/docs/tutorial-06",editUrl:"https://github.com/terasology/TutorialWorldGeneration/edit/develop/docs/docs/06_Additional-Facet-Production.md",version:"current",sidebar:"someSidebar",previous:{title:"Facet Configuration",permalink:"/TutorialWorldGeneration/docs/tutorial-05"},next:{title:"Borders",permalink:"/TutorialWorldGeneration/docs/tutorial-07"}},c=[],l={toc:c};function u(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},l,i,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Another neat way to use facets is to use the data from one or more other facets to create a unique dataset.  In this example we will attempt to create random stone houses on the surface of the world.  For this,  we will create a sparse object 3d facet that will contain the bottom-center locations of each of the houses.  From there we can then create a rasterizer that loops through each of the values and creates a house wherever the facet value should contain a house."),Object(a.b)("p",null,"But first,  the facet class itself:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-java"},"public class HouseFacet extends SparseObjectFacet3D<House> {\n\n    public HouseFacet(Region3i targetRegion, Border3D border) {\n        super(targetRegion, border);\n    }\n}\n")),Object(a.b)("p",null,"There are multiple other options to choose from, but generally they are grouped on their amount of dimensions.\nAn amount of dimensions in this case is just 2D or 3D. You have a whole lot of these to choose from!\nCheck it out here: ",Object(a.b)("a",{parentName:"p",href:"https://github.com/MovingBlocks/Terasology/tree/develop/engine/src/main/java/org/terasology/engine/world/generation/facets/base"},"https://github.com/MovingBlocks/Terasology/tree/develop/engine/src/main/java/org/terasology/engine/world/generation/facets/base"),"\nAs the name suggests, these are base classes. Interfaces are also in that package."),Object(a.b)("p",null,"Easy when immortius has already created the plumbing!  "),Object(a.b)("p",null,"Before we can actually set up the house facet, there's one other thing we need to add first. If we use the ",Object(a.b)("inlineCode",{parentName:"p"},"ElevationFacet")," to check how high to place each house, it restricts us to not having multiple houses one above another if the world generator produces overhanging terrain. In this case it can't, yet, but other ",Object(a.b)("a",{parentName:"p",href:"https://github.com/Terasology/TutorialWorldGeneration/wiki/Plugins"},"plugins")," may change this, so it's best to be prepared just in case (and for consistency). The ",Object(a.b)("inlineCode",{parentName:"p"},"SurfacesFacet")," stores information on the detailed shape of the surface of the ground, potentially including multiple or 0 heights per column. In this case, we can just set it to initially contain the same data as the ",Object(a.b)("inlineCode",{parentName:"p"},"ElevationFacet"),"."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-java"},"@Produces(SurfacesFacet.class)\n@Requires(@Facet(ElevationFacet.class))\npublic class SurfacesProvider implements FacetProvider {\n\n    @Override\n    public void setSeed(long seed) {\n\n    }\n\n    @Override\n    public void process(GeneratingRegion region) {\n        ElevationFacet elevation = region.getRegionFacet(ElevationFacet.class);\n        SurfacesFacet surfacesFacet = new SurfacesFacet(region.getRegion(), region.getBorderForFacet(SurfacesFacet.class));\n\n        for (BaseVector2i pos : elevation.getWorldRegion().contents()) {\n            int height = (int) Math.ceil(elevation.getWorld(pos)) - 1;\n            if (height >= surfacesFacet.getWorldRegion().minY() && height <= surfacesFacet.getWorldRegion().maxY()) {\n                surfacesFacet.setWorld(pos.x(), height, pos.y(), true);\n            }\n        }\n        region.setRegionFacet(SurfacesFacet.class, surfacesFacet);\n    }\n}\n")),Object(a.b)("p",null,"Now the ",Object(a.b)("inlineCode",{parentName:"p"},"FacetProvider")," for the houses themselves:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-java"},"@Produces(HouseFacet.class)\n@Requires(@Facet(SurfacesFacet.class))\npublic class HouseProvider implements FacetProvider {\n\n    private Noise noise;\n\n    @Override\n    public void setSeed(long seed) {\n        noise = new WhiteNoise(seed);\n    }\n\n    @Override\n    public void process(GeneratingRegion region) {\n\n        Border3D border = region.getBorderForFacet(HouseFacet.class).extendBy(0, 8, 4);\n        HouseFacet facet = new HouseFacet(region.getRegion(), border);\n        SurfacesFacet surfacesFacet = region.getRegionFacet(SurfacesFacet.class);\n\n        Region3i worldRegion = surfacesFacet.getWorldRegion();\n\n        for (int wz = worldRegion.minZ(); wz <= worldRegion.maxZ(); wz++) {\n            for (int wx = worldRegion.minX(); wx <= worldRegion.maxX(); wx++) {\n                for (int surfaceHeight : surfacesFacet.getWorldColumn(wx, wz)) {\n\n                    // TODO: check for overlap\n                    if (noise.noise(wx, wz) > 0.99) {\n                        facet.setWorld(wx, surfaceHeight, wz, new House());\n                    }\n                }\n            }\n        }\n\n        region.setRegionFacet(HouseFacet.class, facet);\n    }\n}\n")),Object(a.b)("p",null,"Here we are discarding 99% of the positions and placing a house at the remaining positions at the surface height when in the range of the facet."),Object(a.b)("p",null,"Now we will go ahead and define what a house object actually is. Because our houses are simple 8x8x8 hollow cubes, we can easily create a house class and define a ",Object(a.b)("inlineCode",{parentName:"p"},"getExtent()")," method that returns 4."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-java"},"public class House {\n    public int getExtent() {\n        return 4;\n    }\n}\n")),Object(a.b)("p",null,'The last remaining piece is to rasterize these "houses" into the world and then plug all them in to the world builder.'),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-java"},'public class HouseRasterizer implements WorldRasterizer {\n    private Block stone;\n\n    @Override\n    public void initialize() {\n        stone = CoreRegistry.get(BlockManager.class).getBlock("CoreAssets:Stone");\n    }\n\n    @Override\n    public void generateChunk(CoreChunk chunk, Region chunkRegion) {\n        HouseFacet houseFacet = chunkRegion.getFacet(HouseFacet.class);\n\n        for (Entry<BaseVector3i, House> entry : houseFacet.getWorldEntries().entrySet()) {\n            // there should be a house here\n            // create a couple 3d regions to help iterate through the cube shape, inside and out\n            Vector3i centerHousePosition = new Vector3i(entry.getKey());\n            int extent = entry.getValue().getExtent();\n            centerHousePosition.add(0, extent, 0);\n            Region3i walls = Region3i.createFromCenterExtents(centerHousePosition, extent);\n            Region3i inside = Region3i.createFromCenterExtents(centerHousePosition, extent - 1);\n\n            // loop through each of the positions in the cube, ignoring the inside\n            for (Vector3i newBlockPosition : walls) {\n                if (chunkRegion.getRegion().encompasses(newBlockPosition)\n                        && !inside.encompasses(newBlockPosition)) {\n                    chunk.setBlock(ChunkMath.calcBlockPos(newBlockPosition), stone);\n                }\n            }\n        }\n    }\n}\n')),Object(a.b)("p",null,"Now just add the ",Object(a.b)("inlineCode",{parentName:"p"},"SurfacesProvider"),", ",Object(a.b)("inlineCode",{parentName:"p"},"HouseProvider")," and ",Object(a.b)("inlineCode",{parentName:"p"},"HouseRasterizer")," to the world builder."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-java"},"    @Override\n    protected WorldBuilder createWorld(long seed) {\n        return new WorldBuilder(seed)\n                .addProvider(new SurfaceProvider())\n                .addProvider(new SeaLevelProvider(0))\n                .addProvider(new MountainsProvider())\n                .addProvider(new SurfacesProvider())\n                .addProvider(new HouseProvider())\n                .addRasterizer(new TutorialWorldRasterizer())\n                .addRasterizer(new HouseRasterizer());\n    }\n")),Object(a.b)("p",null,"Bingo.  The world is now a village of boring stone dwelling hermits!"),Object(a.b)("p",null,Object(a.b)("img",{alt:"Additiona House Facet 1",src:n(142).default}),"\n",Object(a.b)("img",{alt:"Additiona House Facet 2",src:n(143).default})),Object(a.b)("p",null,"Notice though that there are problems. Some houses are missing walls and roofs.\nThis will happen at the chunk boundary where the neighboring chunk does not know that it should be generating the edge of the house in its chunk."))}u.isMDXComponent=!0},96:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return g}));var o=n(0),r=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),u=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=u(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=u(n),p=o,g=d["".concat(i,".").concat(p)]||d[p]||h[p]||a;return n?r.a.createElement(g,s(s({ref:t},l),{},{components:n})):r.a.createElement(g,s({ref:t},l))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);